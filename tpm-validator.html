<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TPM Timesheet Validation Dashboard</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="./style.css">
    <style>
        .validation-dashboard {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
        }
        
        .validation-panels {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .file-management-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .validation-results-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .file-upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }
        
        .file-upload-area:hover {
            border-color: #007bff;
        }
        
        .file-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .file-item:hover {
            background-color: #f8f9fa;
        }
        
        .file-item.selected {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }
        
        .file-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .status-pending { background-color: #ffc107; }
        .status-validating { background-color: #17a2b8; }
        .status-pass { background-color: #28a745; }
        .status-fail { background-color: #dc3545; }
        .status-error { background-color: #6c757d; }
        
        .validation-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .summary-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid;
        }
        
        .summary-card.total { border-left-color: #6c757d; }
        .summary-card.pass { border-left-color: #28a745; }
        .summary-card.fail { border-left-color: #dc3545; }
        .summary-card.pending { border-left-color: #ffc107; }
        
        .detail-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .validation-rules-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .validation-rules-table th,
        .validation-rules-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .validation-rules-table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        
        .rule-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .rule-pass {
            color: #28a745;
            font-weight: 600;
        }
        
        .rule-fail {
            color: #dc3545;
            font-weight: 600;
        }
        
        .error-details {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            padding: 8px;
            margin-top: 5px;
            font-size: 0.9em;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0056b3;
        }
        
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #1e7e34;
        }
        
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #c82333;
        }
        
        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }
        
        .btn-warning:hover {
            background-color: #e0a800;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #6c757d;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="validation-dashboard">
        <div class="dashboard-header">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <button onclick="window.location.href='index.html'" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 16px; border-radius: 5px; cursor: pointer;">â† è¿”å›é¦–é </button>
                <h1 style="margin: 0;">ğŸ›¡ï¸ TPM Timesheet Validation Dashboard</h1>
                <div style="width: 80px;"></div> <!-- Spacer for alignment -->
            </div>
            <p>Comprehensive validation tool for timesheet CSV files with business rule compliance checking</p>
        </div>
        
        <div class="validation-panels">
            <!-- File Management Panel -->
            <div class="file-management-panel">
                <h3>ğŸ“ File Management</h3>
                
                <div class="file-upload-area" id="file-upload-area">
                    <div>
                        <i>ğŸ“¤</i>
                        <p><strong>Drop CSV files here</strong></p>
                        <p>or click to select multiple files</p>
                        <input type="file" id="csv-file-input" multiple accept=".csv" style="display: none;">
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button class="btn btn-primary" id="btn-select-files">Select Files</button>
                    <button class="btn btn-success" id="btn-validate-all">Validate All</button>
                    <button class="btn btn-warning" id="btn-export-all-passed" style="display: none;">åŒ¯å‡ºæ‰€æœ‰é€šéæª”æ¡ˆ</button>
                    <button class="btn btn-danger" id="btn-clear-all">Clear All</button>
                </div>
                
                <!-- Previous export merge section -->
                <div class="merge-previous-section" id="merge-previous-section" style="display: none; margin-top: 20px; padding: 15px; border: 2px dashed #ffc107; border-radius: 10px; background-color: #fff3cd;">
                    <h4 style="margin: 0 0 10px 0; color: #856404;">ğŸ“¥ åˆä½µä¹‹å‰çš„ TPM åŒ¯å‡ºæª”æ¡ˆ</h4>
                    <p style="margin: 0 0 10px 0; font-size: 14px; color: #856404;">å¦‚æœæ‚¨æœ‰ä¹‹å‰åŒ¯å‡ºçš„ TPM æª”æ¡ˆï¼Œå¯ä»¥é¸æ“‡åˆä½µåˆ°é€™æ¬¡çš„åŒ¯å‡ºä¸­</p>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="previous-export-file" accept=".csv" style="display: none;">
                        <button class="btn btn-secondary" id="btn-select-previous">é¸æ“‡ä¹‹å‰çš„åŒ¯å‡ºæª”æ¡ˆ</button>
                        <span id="previous-file-name" style="color: #28a745; font-weight: bold;"></span>
                        <button class="btn btn-sm btn-danger" id="btn-clear-previous" style="display: none; padding: 5px 10px; font-size: 12px;">ç§»é™¤</button>
                    </div>
                </div>
                
                <div class="file-list" id="file-list">
                    <!-- Files will be dynamically added here -->
                </div>
            </div>
            
            <!-- Validation Results Panel -->
            <div class="validation-results-panel">
                <h3>ğŸ“Š Validation Summary</h3>
                
                <div class="validation-summary">
                    <div class="summary-card total">
                        <h4 id="total-files">0</h4>
                        <p>Total Files</p>
                    </div>
                    <div class="summary-card pass">
                        <h4 id="pass-files">0</h4>
                        <p>Passed</p>
                    </div>
                    <div class="summary-card fail">
                        <h4 id="fail-files">0</h4>
                        <p>Failed</p>
                    </div>
                    <div class="summary-card pending">
                        <h4 id="pending-files">0</h4>
                        <p>Pending</p>
                    </div>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="validation-progress" style="width: 0%"></div>
                </div>
                
                <div id="overall-status" class="loading hidden">
                    Ready to validate files...
                </div>
                
                <div id="validation-status" style="text-align: center; padding: 10px; color: #6c757d; font-style: italic;">
                    æº–å‚™é©—è­‰æª”æ¡ˆ...
                </div>
            </div>
        </div>
        
        <!-- Detailed Validation Results Panel -->
        <div class="detail-panel" id="detail-panel">
            <h3 id="detail-panel-title">ğŸ” Select a file to view detailed validation results</h3>
            
            <div id="detail-content" class="hidden">
                <div class="file-info">
                    <h4 id="selected-file-name">File Name</h4>
                    <p id="selected-file-info">File information will appear here</p>
                </div>
                
                <table class="validation-rules-table">
                    <thead>
                        <tr>
                            <th>Validation Rule</th>
                            <th>Status</th>
                            <th>Issues Found</th>
                            <th>Details</th>
                        </tr>
                    </thead>
                    <tbody id="validation-results-tbody">
                        <!-- Validation results will be dynamically populated here -->
                    </tbody>
                </table>
                
                <div class="action-buttons">
                    <button class="btn btn-primary" id="btn-revalidate-file">Re-validate File</button>
                    <button class="btn btn-success" id="btn-export-corrected" style="display: none;">åŒ¯å‡ºæ ¼å¼ä¿®æ­£ç‰ˆ</button>
                    <button class="btn btn-danger" id="btn-remove-file">Remove File</button>
                </div>
            </div>
        </div>
    </div>

    <script src="./app-bundled.js"></script>
    <script>
        // ==================== TPM VALIDATION DASHBOARD ====================
        console.log('ğŸ›¡ï¸ TPM Validation Dashboard loaded');
        
        // Global state management
        let validationFiles = new Map(); // filename -> {file, status, results}
        let referenceData = {
            projects: [],
            products: [],
            activities: []
        };
        
        // Load reference data on page load
        async function loadReferenceData() {
            try {
                console.log('Loading reference data...');
                
                // Load project codes
                const projectResponse = await fetch('projectcode.csv');
                const projectText = await projectResponse.text();
                referenceData.projects = parseCSVContent(projectText);
                
                // Load product codes  
                const productResponse = await fetch('productcode.csv');
                const productText = await productResponse.text();
                referenceData.products = parseCSVContent(productText);
                
                // Load activity types
                const activityResponse = await fetch('activityType.csv');
                const activityText = await activityResponse.text();
                referenceData.activities = parseCSVContent(activityText);
                
                console.log('Reference data loaded:', {
                    projects: referenceData.projects.length,
                    products: referenceData.products.length,
                    activities: referenceData.activities.length
                });
                
                return true;
            } catch (error) {
                console.error('Error loading reference data:', error);
                alert('ç„¡æ³•è¼‰å…¥åƒè€ƒè³‡æ–™æª”æ¡ˆï¼Œè«‹ç¢ºèª CSV æª”æ¡ˆå­˜åœ¨');
                return false;
            }
        }
        
        // CSV parsing function (reuse from app-bundled.js logic)
        function parseCSVContent(text) {
            const cleanText = text.replace(/^\uFEFF/, '');
            const lines = cleanText.trim().split(/\r?\n/);
            if (lines.length < 2) return [];
            
            const headers = parseCSVLine(lines[0]);
            
            return lines.slice(1).map(line => {
                if (!line.trim()) return null;
                const fields = parseCSVLine(line);
                const obj = {};
                headers.forEach((h, i) => {
                    obj[h] = fields[i] || '';
                });
                
                // Normalize date formats after parsing
                if (obj.Date) {
                    obj.Date = normalizeDateFormat(obj.Date);
                }
                if (obj['Start Date']) {
                    obj['Start Date'] = normalizeDateFormat(obj['Start Date']);
                }
                if (obj['End Date']) {
                    obj['End Date'] = normalizeDateFormat(obj['End Date']);
                }
                
                return obj;
            }).filter(obj => obj !== null);
        }
        
        // CSV line parsing function (from app-bundled.js)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i += 2;
                    } else {
                        inQuotes = !inQuotes;
                        i++;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                    i++;
                } else {
                    current += char;
                    i++;
                }
            }
            result.push(current.trim());
            return result;
        }
        
        // ==================== VALIDATION RULES ====================
        
        // 1. Required fields validation
        function validateRequiredFields(entry, lineNumber) {
            const requiredFields = ['Task', 'Activity Type', 'Zone', 'Project', 'Product Module', 'Regular Hours', 'Date'];
            const errors = [];
            
            requiredFields.forEach(field => {
                if (!entry[field] || String(entry[field]).trim() === '') {
                    errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šç¼ºå°‘å¿…å¡«æ¬„ä½ "${field}"`);
                }
            });
            
            return {
                ruleName: 'å¿…å¡«æ¬„ä½æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥æ‰€æœ‰å¿…å¡«æ¬„ä½æ˜¯å¦æœ‰å€¼'
            };
        }
        
        // Helper function to normalize date format to YYYY/MM/DD
        function normalizeDateFormat(dateStr) {
            if (!dateStr) return dateStr;
            
            // If already in YYYY/MM/DD format with zero padding, return as is
            if (/^\d{4}\/\d{2}\/\d{2}$/.test(dateStr)) {
                return dateStr;
            }
            
            // Convert YYYY-MM-DD to YYYY/MM/DD
            if (dateStr.includes('-')) {
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    const year = parts[0];
                    const month = parts[1].padStart(2, '0');
                    const day = parts[2].padStart(2, '0');
                    return `${year}/${month}/${day}`;
                }
            }
            
            // Convert YYYY/M/D to YYYY/MM/DD (add zero padding)
            if (dateStr.includes('/')) {
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    const year = parts[0];
                    const month = parts[1].padStart(2, '0');
                    const day = parts[2].padStart(2, '0');
                    return `${year}/${month}/${day}`;
                }
            }
            
            return dateStr;
        }

        // 2. Date format validation (only accepts YYYY/MM/DD format)
        function validateDateFormat(entry, lineNumber) {
            const errors = [];
            const requiredDatePattern = /^\d{4}\/\d{2}\/\d{2}$/; // Strict YYYY/MM/DD with zero padding
            
            // Check main date field
            if (entry.Date && !requiredDatePattern.test(entry.Date)) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ—¥æœŸæ ¼å¼éŒ¯èª¤ "${entry.Date}"ï¼Œæ‡‰ç‚º YYYY/MM/DD æ ¼å¼ï¼ˆéœ€é›¶å¡«å……ï¼Œå¦‚ï¼š2025/06/09ï¼‰`);
            }
            
            // Check start date if exists
            if (entry['Start Date'] && !requiredDatePattern.test(entry['Start Date'])) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šé–‹å§‹æ—¥æœŸæ ¼å¼éŒ¯èª¤ "${entry['Start Date']}"ï¼Œæ‡‰ç‚º YYYY/MM/DD æ ¼å¼ï¼ˆéœ€é›¶å¡«å……ï¼Œå¦‚ï¼š2025/06/09ï¼‰`);
            }
            
            // Check end date if exists
            if (entry['End Date'] && !requiredDatePattern.test(entry['End Date'])) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šçµæŸæ—¥æœŸæ ¼å¼éŒ¯èª¤ "${entry['End Date']}"ï¼Œæ‡‰ç‚º YYYY/MM/DD æ ¼å¼ï¼ˆéœ€é›¶å¡«å……ï¼Œå¦‚ï¼š2025/06/09ï¼‰`);
            }
            
            return {
                ruleName: 'æ—¥æœŸæ ¼å¼æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥æ—¥æœŸæ˜¯å¦ç¬¦åˆ YYYY/MM/DD æ ¼å¼ï¼ˆéœ€é›¶å¡«å……ï¼‰'
            };
        }
        
        // 3. Regular hours limitation (max 8 hours)
        function validateRegularHours(entry, lineNumber) {
            const errors = [];
            const regularHours = parseFloat(entry['Regular Hours']) || 0;
            
            if (regularHours > 8) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ­£å¸¸å·¥æ™‚ ${regularHours} å°æ™‚è¶…é 8 å°æ™‚é™åˆ¶`);
            }
            
            if (regularHours < 0) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ­£å¸¸å·¥æ™‚ä¸èƒ½ç‚ºè² æ•¸ ${regularHours}`);
            }
            
            return {
                ruleName: 'æ­£å¸¸å·¥æ™‚é™åˆ¶æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥æ­£å¸¸å·¥æ™‚æ˜¯å¦è¶…é 8 å°æ™‚é™åˆ¶'
            };
        }
        
        // 4. Zone/Project relationship validation
        function validateZoneProjectRelationship(entry, lineNumber) {
            const errors = [];
            const zone = entry.Zone;
            const project = entry.Project;
            
            if (zone && project) {
                const validProject = referenceData.projects.find(p => 
                    p.Zone === zone && p.Project === project
                );
                
                if (!validProject) {
                    errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šZone "${zone}" èˆ‡ Project "${project}" çš„çµ„åˆä¸å­˜åœ¨æ–¼åƒè€ƒè³‡æ–™ä¸­`);
                }
            }
            
            return {
                ruleName: 'Zone/Project é—œä¿‚æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥ Zone å’Œ Project çš„çµ„åˆæ˜¯å¦å­˜åœ¨æ–¼ projectcode.csv ä¸­'
            };
        }
        
        // 5. Zone/Product relationship validation
        function validateZoneProductRelationship(entry, lineNumber) {
            const errors = [];
            const zone = entry.Zone;
            const productModule = entry['Product Module'];
            
            if (zone && productModule) {
                const validProduct = referenceData.products.find(p => 
                    p.Zone === zone && p['Product Module'] === productModule
                );
                
                if (!validProduct) {
                    errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šZone "${zone}" èˆ‡ Product Module "${productModule}" çš„çµ„åˆä¸å­˜åœ¨æ–¼åƒè€ƒè³‡æ–™ä¸­`);
                }
            }
            
            return {
                ruleName: 'Zone/Product é—œä¿‚æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥ Zone å’Œ Product Module çš„çµ„åˆæ˜¯å¦å­˜åœ¨æ–¼ productcode.csv ä¸­'
            };
        }
        
        // 6. Project/PM mapping validation
        function validateProjectPMMapping(entry, lineNumber) {
            const errors = [];
            const project = entry.Project;
            const zone = entry.Zone;
            const pmField = entry.PM;
            
            if (project && zone) {
                const projectData = referenceData.projects.find(p => 
                    p.Zone === zone && p.Project === project
                );
                
                if (projectData && projectData.PM && pmField) {
                    if (projectData.PM !== pmField) {
                        errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šProject "${project}" çš„ PM æ‡‰ç‚º "${projectData.PM}"ï¼Œä½†å¡«å…¥ "${pmField}"`);
                    }
                }
            }
            
            return {
                ruleName: 'Project/PM å°æ‡‰æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥ Project å’Œ PM çš„å°æ‡‰é—œä¿‚æ˜¯å¦æ­£ç¢º'
            };
        }
        
        // 7. Admin/Training activity validation
        function validateAdminTrainingActivity(entry, lineNumber) {
            const errors = [];
            const activityType = entry['Activity Type'];
            const zone = entry.Zone;
            const project = entry.Project;
            const productModule = entry['Product Module'];
            
            if (activityType === 'Admin / Training') {
                if (zone !== 'Admin') {
                    errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ´»å‹•é¡å‹ç‚º "Admin / Training" æ™‚ï¼ŒZone å¿…é ˆç‚º "Admin"ï¼Œä½†å¡«å…¥ "${zone}"`);
                }
                
                if (project !== 'Admin') {
                    errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ´»å‹•é¡å‹ç‚º "Admin / Training" æ™‚ï¼ŒProject å¿…é ˆç‚º "Admin"ï¼Œä½†å¡«å…¥ "${project}"`);
                }
                
                if (productModule !== 'Non Product Non Product') {
                    errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ´»å‹•é¡å‹ç‚º "Admin / Training" æ™‚ï¼ŒProduct Module å¿…é ˆç‚º "Non Product Non Product"ï¼Œä½†å¡«å…¥ "${productModule}"`);
                }
            }
            
            return {
                ruleName: 'Admin/Training æ´»å‹•é¡å‹æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥ Admin/Training æ´»å‹•é¡å‹çš„ Zone/Project/Product è¨­å®šæ˜¯å¦æ­£ç¢º'
            };
        }
        
        // 8. Activity type validation
        function validateActivityType(entry, lineNumber) {
            const errors = [];
            const activityType = entry['Activity Type'];
            
            if (activityType) {
                const validActivity = referenceData.activities.find(a => 
                    a['Activity Type'] === activityType
                );
                
                if (!validActivity) {
                    errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ´»å‹•é¡å‹ "${activityType}" ä¸å­˜åœ¨æ–¼åƒè€ƒè³‡æ–™ä¸­`);
                }
            }
            
            return {
                ruleName: 'æ´»å‹•é¡å‹æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥æ´»å‹•é¡å‹æ˜¯å¦å­˜åœ¨æ–¼ activityType.csv ä¸­'
            };
        }
        
        // 9. Numeric validation for hours
        function validateNumericFields(entry, lineNumber) {
            const errors = [];
            
            // Regular Hours validation
            const regularHours = entry['Regular Hours'];
            if (regularHours && isNaN(parseFloat(regularHours))) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šæ­£å¸¸å·¥æ™‚ "${regularHours}" ä¸æ˜¯æœ‰æ•ˆæ•¸å­—`);
            }
            
            // OT Hours validation
            const otHours = entry['OT Hours'];
            if (otHours && isNaN(parseFloat(otHours))) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šåŠ ç­å·¥æ™‚ "${otHours}" ä¸æ˜¯æœ‰æ•ˆæ•¸å­—`);
            }
            
            // TTL Hours validation
            const ttlHours = entry['TTL_Hours'];
            if (ttlHours && isNaN(parseFloat(ttlHours))) {
                errors.push(`ç¬¬ ${lineNumber} è¡Œï¼šç¸½å·¥æ™‚ "${ttlHours}" ä¸æ˜¯æœ‰æ•ˆæ•¸å­—`);
            }
            
            return {
                ruleName: 'æ•¸å­—æ¬„ä½æ ¼å¼æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥å·¥æ™‚æ¬„ä½æ˜¯å¦ç‚ºæœ‰æ•ˆæ•¸å­—'
            };
        }
        
        // 10. Weekly total regular hours validation (must be 40 hours)
        function validateWeeklyTotalHours(entries) {
            const errors = [];
            
            // Calculate total regular hours for the week
            let totalRegularHours = 0;
            entries.forEach((entry, index) => {
                const regularHours = parseFloat(entry['Regular Hours']) || 0;
                totalRegularHours += regularHours;
            });
            
            // Check if total is exactly 40 hours
            if (totalRegularHours !== 40) {
                errors.push(`å…¨é€±æ­£å¸¸å·¥æ™‚åŠ ç¸½ ${totalRegularHours} å°æ™‚ï¼Œä¸ç­‰æ–¼è¦æ±‚çš„ 40 å°æ™‚`);
            }
            
            return {
                ruleName: 'é€±ç¸½å·¥æ™‚æª¢æŸ¥',
                passed: errors.length === 0,
                errors: errors,
                description: 'æª¢æŸ¥å…¨é€±æ­£å¸¸å·¥æ™‚åŠ ç¸½æ˜¯å¦ç‚º 40 å°æ™‚'
            };
        }
        
        // Master validation function
        async function validateCSVFile(file) {
            try {
                console.log(`ğŸ” é–‹å§‹é©—è­‰æª”æ¡ˆ: ${file.name}`);
                
                const text = await file.text();
                const entries = parseCSVContent(text);
                
                if (entries.length === 0) {
                    return {
                        fileName: file.name,
                        status: 'error',
                        totalEntries: 0,
                        passedRules: 0,
                        failedRules: 0,
                        overallResult: 'FAIL',
                        validationResults: [],
                        data: [], // Add empty data array for consistency
                        summary: 'æª”æ¡ˆç‚ºç©ºæˆ–æ ¼å¼éŒ¯èª¤'
                    };
                }
                
                console.log(`ğŸ“Š è§£æäº† ${entries.length} ç­†è¨˜éŒ„`);
                
                const validationResults = [];
                let totalPassed = 0;
                let totalFailed = 0;
                
                // Run all validation rules for all entries
                entries.forEach((entry, index) => {
                    const lineNumber = index + 2; // +2 because of header row and 0-based index
                    
                    const rules = [
                        validateRequiredFields(entry, lineNumber),
                        validateDateFormat(entry, lineNumber),
                        validateRegularHours(entry, lineNumber),
                        validateZoneProjectRelationship(entry, lineNumber),
                        validateZoneProductRelationship(entry, lineNumber),
                        validateProjectPMMapping(entry, lineNumber),
                        validateAdminTrainingActivity(entry, lineNumber),
                        validateActivityType(entry, lineNumber),
                        validateNumericFields(entry, lineNumber)
                    ];
                    
                    rules.forEach(rule => {
                        if (rule.passed) {
                            totalPassed++;
                        } else {
                            totalFailed++;
                        }
                        
                        const existingRule = validationResults.find(r => r.ruleName === rule.ruleName);
                        if (existingRule) {
                            existingRule.errors.push(...rule.errors);
                            existingRule.passed = existingRule.passed && rule.passed;
                        } else {
                            validationResults.push({
                                ruleName: rule.ruleName,
                                description: rule.description,
                                passed: rule.passed,
                                errors: [...rule.errors]
                            });
                        }
                    });
                });
                
                // Add weekly total hours validation
                const weeklyTotalRule = validateWeeklyTotalHours(entries);
                if (weeklyTotalRule.passed) {
                    totalPassed++;
                } else {
                    totalFailed++;
                }
                
                const existingWeeklyRule = validationResults.find(r => r.ruleName === weeklyTotalRule.ruleName);
                if (existingWeeklyRule) {
                    existingWeeklyRule.errors.push(...weeklyTotalRule.errors);
                    existingWeeklyRule.passed = existingWeeklyRule.passed && weeklyTotalRule.passed;
                } else {
                    validationResults.push({
                        ruleName: weeklyTotalRule.ruleName,
                        description: weeklyTotalRule.description,
                        passed: weeklyTotalRule.passed,
                        errors: [...weeklyTotalRule.errors]
                    });
                }
                
                const overallResult = totalFailed === 0 ? 'PASS' : 'FAIL';
                
                console.log(`âœ… é©—è­‰å®Œæˆ: ${file.name} - ${overallResult}`);
                
                return {
                    fileName: file.name,
                    status: 'completed',
                    totalEntries: entries.length,
                    passedRules: totalPassed,
                    failedRules: totalFailed,
                    overallResult: overallResult,
                    validationResults: validationResults,
                    data: entries, // Include the parsed data
                    summary: `å…± ${entries.length} ç­†è¨˜éŒ„ï¼Œ${totalFailed} å€‹é©—è­‰éŒ¯èª¤`
                };
                
            } catch (error) {
                console.error(`âŒ é©—è­‰æª”æ¡ˆ ${file.name} æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                return {
                    fileName: file.name,
                    status: 'error',
                    totalEntries: 0,
                    passedRules: 0,
                    failedRules: 0,
                    overallResult: 'ERROR',
                    validationResults: [],
                    data: [], // Empty data array for error case
                    summary: `é©—è­‰æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`
                };
            }
        }
        
        // ==================== UI MANAGEMENT ====================
        
        function updateSummaryCards() {
            const totalFiles = validationFiles.size;
            const passFiles = Array.from(validationFiles.values()).filter(f => f.status === 'completed' && f.results?.overallResult === 'PASS').length;
            const failFiles = Array.from(validationFiles.values()).filter(f => f.status === 'completed' && f.results?.overallResult === 'FAIL').length;
            const pendingFiles = Array.from(validationFiles.values()).filter(f => f.status === 'pending').length;
            
            document.getElementById('total-files').textContent = totalFiles;
            document.getElementById('pass-files').textContent = passFiles;
            document.getElementById('fail-files').textContent = failFiles;
            document.getElementById('pending-files').textContent = pendingFiles;
            
            // Show/hide export all passed files button and merge section based on whether there are passed files
            const exportAllButton = document.getElementById('btn-export-all-passed');
            const mergePreviousSection = document.getElementById('merge-previous-section');
            if (passFiles > 0) {
                exportAllButton.style.display = 'inline-block';
                mergePreviousSection.style.display = 'block';
            } else {
                exportAllButton.style.display = 'none';
                mergePreviousSection.style.display = 'none';
            }
        }
        
        function updateFileList() {
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';
            
            if (validationFiles.size === 0) {
                fileList.innerHTML = '<p style="text-align: center; color: #6c757d;">å°šæœªé¸æ“‡æª”æ¡ˆ</p>';
                return;
            }
            
            validationFiles.forEach((fileData, fileName) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.onclick = () => selectFile(fileName);
                
                let statusClass = 'status-pending';
                let statusText = 'å¾…é©—è­‰';
                
                if (fileData.status === 'validating') {
                    statusClass = 'status-validating';
                    statusText = 'é©—è­‰ä¸­...';
                } else if (fileData.status === 'completed') {
                    if (fileData.results?.overallResult === 'PASS') {
                        statusClass = 'status-pass';
                        statusText = 'é€šé';
                    } else {
                        statusClass = 'status-fail';
                        statusText = 'å¤±æ•—';
                    }
                } else if (fileData.status === 'error') {
                    statusClass = 'status-error';
                    statusText = 'éŒ¯èª¤';
                }
                
                fileItem.innerHTML = `
                    <div>
                        <strong>${fileName}</strong>
                        <br>
                        <small>${fileData.results?.summary || 'å°šæœªé©—è­‰'}</small>
                    </div>
                    <div class="file-status">
                        <span class="status-indicator ${statusClass}"></span>
                        <span>${statusText}</span>
                    </div>
                `;
                
                fileList.appendChild(fileItem);
            });
        }
        
        function selectFile(fileName) {
            // Remove previous selection
            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selection to clicked item
            event.currentTarget.classList.add('selected');
            
            const fileData = validationFiles.get(fileName);
            showFileDetails(fileData);
        }
        
        function showFileDetails(fileData) {
            const detailPanel = document.getElementById('detail-panel');
            const detailContent = document.getElementById('detail-content');
            const title = document.getElementById('detail-panel-title');
            
            title.textContent = `ğŸ” ${fileData.fileName} è©³ç´°é©—è­‰çµæœ`;
            
            if (!fileData.results) {
                detailContent.innerHTML = '<p>è©²æª”æ¡ˆå°šæœªå®Œæˆé©—è­‰</p>';
                detailContent.classList.remove('hidden');
                return;
            }
            
            document.getElementById('selected-file-name').textContent = fileData.fileName;
            document.getElementById('selected-file-info').textContent = 
                `ç¸½è¨˜éŒ„æ•¸: ${fileData.results.totalEntries} | é©—è­‰çµæœ: ${fileData.results.overallResult} | ${fileData.results.summary}`;
            
            const tbody = document.getElementById('validation-results-tbody');
            tbody.innerHTML = '';
            
            fileData.results.validationResults.forEach(rule => {
                const row = document.createElement('tr');
                
                const statusHtml = rule.passed 
                    ? '<span class="rule-pass">âœ… PASS</span>'
                    : '<span class="rule-fail">âŒ FAIL</span>';
                
                const issuesCount = rule.errors.length;
                const issuesHtml = issuesCount > 0 
                    ? `<span style="color: #dc3545; font-weight: bold;">${issuesCount} å€‹å•é¡Œ</span>`
                    : '<span style="color: #28a745;">ç„¡å•é¡Œ</span>';
                
                const detailsHtml = rule.errors.length > 0 
                    ? `<div class="error-details">${rule.errors.join('<br>')}</div>`
                    : '';
                
                row.innerHTML = `
                    <td>${rule.ruleName}</td>
                    <td class="rule-status">${statusHtml}</td>
                    <td>${issuesHtml}</td>
                    <td>
                        <small>${rule.description}</small>
                        ${detailsHtml}
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Check if we should show the export button (only date format errors)
            const exportButton = document.getElementById('btn-export-corrected');
            if (fileData.results && !fileData.results.overallResult) {
                // Check if only date format errors exist
                const onlyDateFormatErrors = fileData.results.validationResults.every(rule => {
                    if (rule.passed) return true; // Passed rules are ok
                    return rule.ruleName === 'æ—¥æœŸæ ¼å¼æª¢æŸ¥'; // Only date format check failures are acceptable
                });
                
                const hasDateFormatErrors = fileData.results.validationResults.some(rule => 
                    rule.ruleName === 'æ—¥æœŸæ ¼å¼æª¢æŸ¥' && !rule.passed
                );
                
                if (onlyDateFormatErrors && hasDateFormatErrors) {
                    exportButton.style.display = 'inline-block';
                } else {
                    exportButton.style.display = 'none';
                }
            } else {
                exportButton.style.display = 'none';
            }
            
            detailContent.classList.remove('hidden');
        }
        
        // ==================== EVENT HANDLERS ====================
        
        async function handleFileSelection(files) {
            console.log(`ğŸ“ é¸æ“‡äº† ${files.length} å€‹æª”æ¡ˆ`);
            
            for (const file of files) {
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    alert(`æª”æ¡ˆ "${file.name}" ä¸æ˜¯ CSV æ ¼å¼ï¼Œå·²è·³é`);
                    continue;
                }
                
                validationFiles.set(file.name, {
                    file: file,
                    fileName: file.name,
                    status: 'pending',
                    results: null
                });
            }
            
            updateFileList();
            updateSummaryCards();
        }
        
        async function validateAllFiles() {
            const pendingFiles = Array.from(validationFiles.values()).filter(f => f.status === 'pending');
            
            if (pendingFiles.length === 0) {
                alert('æ²’æœ‰å¾…é©—è­‰çš„æª”æ¡ˆ');
                return;
            }
            
            console.log(`ğŸš€ é–‹å§‹æ‰¹æ¬¡é©—è­‰ ${pendingFiles.length} å€‹æª”æ¡ˆ`);
            
            const totalFiles = pendingFiles.length;
            let completedFiles = 0;
            
            for (const fileData of pendingFiles) {
                // Update status to validating
                fileData.status = 'validating';
                updateFileList();
                
                // Perform validation
                const results = await validateCSVFile(fileData.file);
                
                // Update results
                fileData.status = results.status;
                fileData.results = results;
                fileData.data = results.data; // Store the parsed data
                
                completedFiles++;
                
                // Update progress
                const progress = (completedFiles / totalFiles) * 100;
                document.getElementById('validation-progress').style.width = `${progress}%`;
                
                updateFileList();
                updateSummaryCards();
                
                // Small delay to show progress
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.log('âœ… æ‰¹æ¬¡é©—è­‰å®Œæˆ');
            alert('æ‰€æœ‰æª”æ¡ˆé©—è­‰å®Œæˆï¼');
        }
        
        function clearAllFiles() {
            if (validationFiles.size === 0) return;
            
            if (confirm(`ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰ ${validationFiles.size} å€‹æª”æ¡ˆå—ï¼Ÿ`)) {
                validationFiles.clear();
                updateFileList();
                updateSummaryCards();
                
                // Hide detail panel
                document.getElementById('detail-content').classList.add('hidden');
                document.getElementById('detail-panel-title').textContent = 'ğŸ” Select a file to view detailed validation results';
                
                // Reset progress
                document.getElementById('validation-progress').style.width = '0%';
            }
        }
        
        function revalidateCurrentFile() {
            if (!currentSelectedFile) {
                alert('è«‹å…ˆé¸æ“‡è¦é‡æ–°é©—è­‰çš„æª”æ¡ˆ');
                return;
            }
            
            const fileInfo = validationFiles.get(currentSelectedFile);
            if (fileInfo) {
                validateSingleFile(fileInfo.file);
            }
        }
        
        function removeCurrentFile() {
            if (!currentSelectedFile) {
                alert('è«‹å…ˆé¸æ“‡è¦ç§»é™¤çš„æª”æ¡ˆ');
                return;
            }
            
            if (confirm(`ç¢ºå®šè¦ç§»é™¤æª”æ¡ˆ "${currentSelectedFile}" å—ï¼Ÿ`)) {
                validationFiles.delete(currentSelectedFile);
                updateFileList();
                updateSummaryCards();
                
                // Hide detail panel
                document.getElementById('detail-content').classList.add('hidden');
                document.getElementById('detail-panel-title').textContent = 'ğŸ” Select a file to view detailed validation results';
                currentSelectedFile = null;
            }
        }
        
        function exportCorrectedFile() {
            if (!currentSelectedFile) {
                alert('è«‹å…ˆé¸æ“‡è¦åŒ¯å‡ºçš„æª”æ¡ˆ');
                return;
            }
            
            const fileInfo = validationFiles.get(currentSelectedFile);
            if (!fileInfo || !fileInfo.data) {
                alert('ç„¡æ³•å–å¾—æª”æ¡ˆè³‡æ–™');
                return;
            }
            
            try {
                // Create corrected CSV content with proper date format
                const correctedData = fileInfo.data.map(entry => {
                    const correctedEntry = { ...entry };
                    
                    // Apply date format normalization to YYYY/MM/DD
                    if (correctedEntry.Date) {
                        correctedEntry.Date = normalizeDateFormat(correctedEntry.Date);
                    }
                    if (correctedEntry['Start Date']) {
                        correctedEntry['Start Date'] = normalizeDateFormat(correctedEntry['Start Date']);
                    }
                    if (correctedEntry['End Date']) {
                        correctedEntry['End Date'] = normalizeDateFormat(correctedEntry['End Date']);
                    }
                    
                    return correctedEntry;
                });
                
                // Generate CSV headers
                const headers = [
                    'Name', 'Zone', 'Project', 'Product Module', 'Activity Type', 'Task',
                    'Regular Hours', 'OT Hours', 'TTL_Hours', 'Date', 'Start Date', 'End Date',
                    'Comments', 'PM', 'InternalOrOutsource'
                ];
                
                // Generate CSV rows
                const csvRows = [headers];
                correctedData.forEach(entry => {
                    csvRows.push([
                        entry.Name || '',
                        entry.Zone || '',
                        entry.Project || '',
                        entry['Product Module'] || '',
                        entry['Activity Type'] || '',
                        entry.Task || '',
                        entry['Regular Hours'] || '',
                        entry['OT Hours'] || '',
                        entry.TTL_Hours || '',
                        entry.Date || '',
                        entry['Start Date'] || '',
                        entry['End Date'] || '',
                        entry.Comments || '',
                        entry.PM || '',
                        entry.InternalOrOutsource || ''
                    ]);
                });
                
                // Generate CSV content with proper escaping
                const csvContent = csvRows.map(row =>
                    row.map(field => {
                        const fieldStr = String(field);
                        if (fieldStr.includes(',') || fieldStr.includes('\n') || fieldStr.includes('"')) {
                            return '"' + fieldStr.replace(/"/g, '""') + '"';
                        }
                        return fieldStr;
                    }).join(',')
                ).join('\n');
                
                // Create download
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${currentSelectedFile.replace('.csv', '')}_corrected.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                alert(`å·²åŒ¯å‡ºæ ¼å¼ä¿®æ­£ç‰ˆï¼š${currentSelectedFile.replace('.csv', '')}_corrected.csv`);
                
            } catch (error) {
                console.error('åŒ¯å‡ºå¤±æ•—:', error);
                alert('åŒ¯å‡ºå¤±æ•—ï¼Œè«‹æª¢æŸ¥æ§åˆ¶å°éŒ¯èª¤è¨Šæ¯');
            }
        }
        
        function exportAllPassedFiles() {
            // Get all files and categorize them
            const passedFiles = [];
            const failedFiles = [];
            
            validationFiles.forEach((fileInfo, fileName) => {
                if (fileInfo.results) {
                    if (fileInfo.results.overallResult === 'PASS') {
                        passedFiles.push({
                            fileName: fileName,
                            data: fileInfo.data
                        });
                    } else if (fileInfo.results.overallResult === 'FAIL') {
                        failedFiles.push(fileName);
                    }
                }
            });
            
            if (passedFiles.length === 0) {
                alert('æ²’æœ‰é€šéé©—è­‰çš„æª”æ¡ˆå¯ä»¥åŒ¯å‡º');
                return;
            }
            
            // Create detailed confirmation message
            let confirmMessage = `æº–å‚™åŒ¯å‡ºé©—è­‰çµæœï¼š\n\n`;
            confirmMessage += `âœ… é€šéé©—è­‰çš„æª”æ¡ˆ (${passedFiles.length} å€‹)ï¼š\n`;
            passedFiles.forEach(file => {
                confirmMessage += `   â€¢ ${file.fileName}\n`;
            });
            
            if (failedFiles.length > 0) {
                confirmMessage += `\nâŒ æœªé€šéé©—è­‰çš„æª”æ¡ˆ (${failedFiles.length} å€‹)ï¼š\n`;
                failedFiles.forEach(fileName => {
                    confirmMessage += `   â€¢ ${fileName}\n`;
                });
                confirmMessage += `\næ³¨æ„ï¼šæœªé€šéé©—è­‰çš„æª”æ¡ˆå°‡ä¸æœƒåŒ…å«åœ¨åŒ¯å‡ºä¸­ã€‚\n`;
            }
            
            // Check if there's previous export data to merge
            if (previousExportData && previousExportData.length > 0) {
                confirmMessage += `\nğŸ“¥ å°‡åˆä½µä¹‹å‰çš„åŒ¯å‡ºè³‡æ–™ï¼š${previousExportData.length} ç­†è¨˜éŒ„\n`;
                
                // Check for duplicates before export
                const duplicateInfo = checkDuplicateRecords();
                if (duplicateInfo.duplicateCount > 0) {
                    confirmMessage += `âš ï¸ ç™¼ç¾ ${duplicateInfo.duplicateCount} ç­†é‡è¤‡è¨˜éŒ„å°‡è¢«åŒ…å«åœ¨åŒ¯å‡ºä¸­\n`;
                }
            }
            
            const totalNewRecords = passedFiles.reduce((sum, file) => sum + (file.data ? file.data.length : 0), 0);
            const totalRecords = totalNewRecords + (previousExportData ? previousExportData.length : 0);
            
            confirmMessage += `\nç¸½è¨˜éŒ„æ•¸ï¼š${totalRecords} ç­†`;
            confirmMessage += `\nç¢ºå®šè¦åŒ¯å‡ºåˆä½µçš„ CSV æª”æ¡ˆå—ï¼Ÿ`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                // Combine all data: previous export + current passed files
                const allData = [];
                
                // First, add previous export data if available
                if (previousExportData && previousExportData.length > 0) {
                    previousExportData.forEach(entry => {
                        // Apply date format normalization to ensure consistency
                        const normalizedEntry = { ...entry };
                        
                        if (normalizedEntry.Date) {
                            normalizedEntry.Date = normalizeDateFormat(normalizedEntry.Date);
                        }
                        if (normalizedEntry['Start Date']) {
                            normalizedEntry['Start Date'] = normalizeDateFormat(normalizedEntry['Start Date']);
                        }
                        if (normalizedEntry['End Date']) {
                            normalizedEntry['End Date'] = normalizeDateFormat(normalizedEntry['End Date']);
                        }
                        
                        allData.push(normalizedEntry);
                    });
                }
                
                // Then, add current passed file data
                passedFiles.forEach(file => {
                    if (file.data && Array.isArray(file.data)) {
                        file.data.forEach(entry => {
                            // Apply date format normalization to ensure consistency
                            const normalizedEntry = { ...entry };
                            
                            if (normalizedEntry.Date) {
                                normalizedEntry.Date = normalizeDateFormat(normalizedEntry.Date);
                            }
                            if (normalizedEntry['Start Date']) {
                                normalizedEntry['Start Date'] = normalizeDateFormat(normalizedEntry['Start Date']);
                            }
                            if (normalizedEntry['End Date']) {
                                normalizedEntry['End Date'] = normalizeDateFormat(normalizedEntry['End Date']);
                            }
                            
                            allData.push(normalizedEntry);
                        });
                    }
                });
                
                if (allData.length === 0) {
                    alert('åˆä½µçš„æª”æ¡ˆä¸­æ²’æœ‰æœ‰æ•ˆçš„è³‡æ–™');
                    return;
                }
                
                // Generate CSV headers
                const headers = [
                    'Name', 'Zone', 'Project', 'Product Module', 'Activity Type', 'Task',
                    'Regular Hours', 'OT Hours', 'TTL_Hours', 'Date', 'Start Date', 'End Date',
                    'Comments', 'PM', 'InternalOrOutsource'
                ];
                
                // Generate CSV rows
                const csvRows = [headers];
                allData.forEach(entry => {
                    csvRows.push([
                        entry.Name || '',
                        entry.Zone || '',
                        entry.Project || '',
                        entry['Product Module'] || '',
                        entry['Activity Type'] || '',
                        entry.Task || '',
                        entry['Regular Hours'] || '',
                        entry['OT Hours'] || '',
                        entry.TTL_Hours || '',
                        entry.Date || '',
                        entry['Start Date'] || '',
                        entry['End Date'] || '',
                        entry.Comments || '',
                        entry.PM || '',
                        entry.InternalOrOutsource || ''
                    ]);
                });
                
                // Generate CSV content with proper escaping
                const csvContent = csvRows.map(row =>
                    row.map(field => {
                        const fieldStr = String(field);
                        if (fieldStr.includes(',') || fieldStr.includes('\n') || fieldStr.includes('"')) {
                            return '"' + fieldStr.replace(/"/g, '""') + '"';
                        }
                        return fieldStr;
                    }).join(',')
                ).join('\n');
                
                // Create download with timestamp
                const now = new Date();
                const timestamp = now.toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `TPM_Validated_Combined_${timestamp}.csv`;
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Create detailed success message
                let successMessage = `ğŸ‰ åŒ¯å‡ºæˆåŠŸï¼\n\n`;
                successMessage += `ğŸ“ æª”æ¡ˆåç¨±ï¼š${filename}\n`;
                successMessage += `ğŸ“Š ç¸½è¨˜éŒ„æ•¸ï¼š${allData.length} ç­†\n\n`;
                successMessage += `ğŸ“‹ åŒ¯å‡ºå…§å®¹ï¼š\n`;
                
                if (previousExportData && previousExportData.length > 0) {
                    successMessage += `  â€¢ ä¹‹å‰çš„åŒ¯å‡ºè³‡æ–™ï¼š${previousExportData.length} ç­†\n`;
                }
                
                const newRecords = allData.length - (previousExportData ? previousExportData.length : 0);
                successMessage += `  â€¢ æœ¬æ¬¡é€šéé©—è­‰ï¼š${newRecords} ç­† (ä¾†è‡ª ${passedFiles.length} å€‹æª”æ¡ˆ)\n`;
                
                if (failedFiles.length > 0) {
                    successMessage += `\nâš ï¸ æœªåŒ…å« ${failedFiles.length} å€‹æœªé€šéé©—è­‰çš„æª”æ¡ˆ`;
                }
                
                alert(successMessage);
                
            } catch (error) {
                console.error('åˆä½µåŒ¯å‡ºå¤±æ•—:', error);
                alert('åˆä½µåŒ¯å‡ºå¤±æ•—ï¼Œè«‹æª¢æŸ¥æ§åˆ¶å°éŒ¯èª¤è¨Šæ¯');
            }
        }
        
        // ==================== PREVIOUS EXPORT MERGE FUNCTIONS ====================
        
        let previousExportData = null;
        
        // Generate a unique key for a record to detect duplicates
        function generateRecordKey(entry) {
            // Use key fields to create a unique identifier
            return `${entry.Name || ''}_${entry.Zone || ''}_${entry.Project || ''}_${entry.Task || ''}_${entry.Date || ''}_${entry['Regular Hours'] || ''}_${entry['OT Hours'] || ''}`;
        }
        
        // Check for duplicate records between previous export and current passed files
        function checkDuplicateRecords() {
            if (!previousExportData || previousExportData.length === 0) {
                return { duplicateCount: 0, duplicateDetails: [] };
            }
            
            // Get all current passed file data
            const currentPassedData = [];
            validationFiles.forEach((fileInfo, fileName) => {
                if (fileInfo.results && fileInfo.results.overallResult === 'PASS' && fileInfo.data) {
                    fileInfo.data.forEach(entry => {
                        currentPassedData.push({
                            fileName: fileName,
                            entry: entry,
                            key: generateRecordKey(entry)
                        });
                    });
                }
            });
            
            // Create a set of current record keys for fast lookup
            const currentRecordKeys = new Set(currentPassedData.map(item => item.key));
            
            // Find duplicates in previous export data
            const duplicates = [];
            const previousRecordKeys = new Set();
            
            previousExportData.forEach((entry, index) => {
                const key = generateRecordKey(entry);
                if (currentRecordKeys.has(key)) {
                    duplicates.push({
                        index: index,
                        entry: entry,
                        key: key
                    });
                }
                previousRecordKeys.add(key);
            });
            
            return {
                duplicateCount: duplicates.length,
                duplicateDetails: duplicates,
                totalPreviousRecords: previousExportData.length,
                totalCurrentRecords: currentPassedData.length
            };
        }
        
        function handlePreviousFileSelection(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    const parsedData = parseCSVContent(text);
                    
                    if (parsedData.length === 0) {
                        alert('é¸æ“‡çš„æª”æ¡ˆæ ¼å¼ä¸æ­£ç¢ºæˆ–ç‚ºç©º');
                        return;
                    }
                    
                    previousExportData = parsedData;
                    
                    // Check for duplicates with current passed files
                    const duplicateInfo = checkDuplicateRecords();
                    
                    let displayText = `âœ“ ${file.name} (${parsedData.length} ç­†è¨˜éŒ„)`;
                    if (duplicateInfo.duplicateCount > 0) {
                        displayText += ` - âš ï¸ ç™¼ç¾ ${duplicateInfo.duplicateCount} ç­†é‡è¤‡è¨˜éŒ„`;
                    }
                    
                    document.getElementById('previous-file-name').textContent = displayText;
                    document.getElementById('btn-clear-previous').style.display = 'inline-block';
                    
                    // Show detailed duplicate information if any
                    if (duplicateInfo.duplicateCount > 0) {
                        console.log('ğŸ” é‡è¤‡è¨˜éŒ„è©³æƒ…:', duplicateInfo);
                        const message = `è¼‰å…¥ä¹‹å‰çš„åŒ¯å‡ºæª”æ¡ˆå®Œæˆï¼\n\n` +
                            `ğŸ“Š çµ±è¨ˆè³‡è¨Šï¼š\n` +
                            `â€¢ ä¹‹å‰åŒ¯å‡ºæª”æ¡ˆï¼š${duplicateInfo.totalPreviousRecords} ç­†è¨˜éŒ„\n` +
                            `â€¢ ç›®å‰é€šéé©—è­‰ï¼š${duplicateInfo.totalCurrentRecords} ç­†è¨˜éŒ„\n` +
                            `â€¢ é‡è¤‡è¨˜éŒ„ï¼š${duplicateInfo.duplicateCount} ç­†\n\n` +
                            `âš ï¸ æ³¨æ„ï¼šåˆä½µåŒ¯å‡ºæ™‚ï¼Œé‡è¤‡çš„è¨˜éŒ„å°‡æœƒåŒ…å«åœ¨æœ€çµ‚æª”æ¡ˆä¸­ã€‚\n` +
                            `å¦‚æœæ‚¨ä¸å¸Œæœ›æœ‰é‡è¤‡è¨˜éŒ„ï¼Œè«‹æ‰‹å‹•æª¢æŸ¥ä¸¦æ¸…ç†è³‡æ–™ã€‚`;
                        alert(message);
                    } else {
                        alert(`è¼‰å…¥ä¹‹å‰çš„åŒ¯å‡ºæª”æ¡ˆå®Œæˆï¼\n\n` +
                            `ğŸ“Š çµ±è¨ˆè³‡è¨Šï¼š\n` +
                            `â€¢ ä¹‹å‰åŒ¯å‡ºæª”æ¡ˆï¼š${parsedData.length} ç­†è¨˜éŒ„\n` +
                            `â€¢ ç›®å‰é€šéé©—è­‰ï¼š${duplicateInfo.totalCurrentRecords} ç­†è¨˜éŒ„\n` +
                            `â€¢ é‡è¤‡è¨˜éŒ„ï¼šç„¡\n\n` +
                            `âœ… æ²’æœ‰ç™¼ç¾é‡è¤‡è¨˜éŒ„ï¼Œå¯ä»¥å®‰å…¨åˆä½µã€‚`);
                    }
                    
                } catch (error) {
                    alert('è®€å–ä¹‹å‰çš„åŒ¯å‡ºæª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ­£ç¢º');
                    console.error('è§£æä¹‹å‰åŒ¯å‡ºæª”æ¡ˆéŒ¯èª¤:', error);
                }
            };
            reader.readAsText(file);
        }
        
        function clearPreviousFile() {
            previousExportData = null;
            document.getElementById('previous-file-name').textContent = '';
            document.getElementById('btn-clear-previous').style.display = 'none';
            document.getElementById('previous-export-file').value = '';
            console.log('ğŸ—‘ï¸ å·²æ¸…é™¤ä¹‹å‰çš„åŒ¯å‡ºæª”æ¡ˆ');
        }
        
        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('ğŸ“‹ åˆå§‹åŒ– TPM é©—è­‰å„€è¡¨æ¿...');
            
            // Load reference data first
            const loaded = await loadReferenceData();
            if (!loaded) {
                document.getElementById('overall-status').textContent = 'âŒ ç„¡æ³•è¼‰å…¥åƒè€ƒè³‡æ–™ï¼Œè«‹æª¢æŸ¥ CSV æª”æ¡ˆ';
                document.getElementById('overall-status').classList.remove('hidden');
                return;
            }
            
            // Set up file upload
            const fileInput = document.getElementById('csv-file-input');
            const uploadArea = document.getElementById('file-upload-area');
            
            // File input change
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileSelection(Array.from(e.target.files));
                }
            });
            
            // Drag and drop
            uploadArea.addEventListener('click', () => fileInput.click());
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#007bff';
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#ccc';
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#ccc';
                
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.toLowerCase().endsWith('.csv'));
                if (files.length > 0) {
                    handleFileSelection(files);
                }
            });
            
            // Button events
            document.getElementById('btn-select-files').addEventListener('click', () => fileInput.click());
            document.getElementById('btn-validate-all').addEventListener('click', validateAllFiles);
            document.getElementById('btn-clear-all').addEventListener('click', clearAllFiles);
            document.getElementById('btn-export-all-passed').addEventListener('click', exportAllPassedFiles);
            document.getElementById('btn-export-corrected').addEventListener('click', exportCorrectedFile);
            document.getElementById('btn-revalidate-file').addEventListener('click', revalidateCurrentFile);
            document.getElementById('btn-remove-file').addEventListener('click', removeCurrentFile);
            
            // Previous export merge events
            const previousExportInput = document.getElementById('previous-export-file');
            document.getElementById('btn-select-previous').addEventListener('click', () => {
                previousExportInput.value = ''; // Clear value to ensure change event fires
                previousExportInput.click();
            });
            document.getElementById('btn-clear-previous').addEventListener('click', clearPreviousFile);
            previousExportInput.addEventListener('change', handlePreviousFileSelection);
            
            console.log('âœ… TPM é©—è­‰å„€è¡¨æ¿åˆå§‹åŒ–å®Œæˆ');
        });
    </script>
</body>
</html>